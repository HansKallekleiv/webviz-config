#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# AUTOMATICALLY MADE FILE. DO NOT EDIT.
# This file was generated by {{ author }} on {{ current_date }}.

import logging
import logging.config
import threading
import datetime
import os.path as path
from pathlib import Path, PosixPath
from collections import defaultdict

import dash
from dash.dependencies import Input, Output, State
import dash_bootstrap_components as dbc
import dash_core_components as dcc
import dash_html_components as html
from flask_talisman import Talisman
import webviz_config
from webviz_config.themes import installed_themes
from webviz_config.common_cache import CACHE
from webviz_config.webviz_store import WEBVIZ_STORAGE
from webviz_config.webviz_assets import WEBVIZ_ASSETS

{% for module in _imports %}
{%- if module is string -%}
import {{ module }}
{%- else -%}
import {{ module[0] }} as {{ module[1] }}
{%- endif %}
{% endfor %}

# We do not want to show INFO regarding werkzeug routing as that is too verbose,
# however we want other log handlers (typically coming from webviz plugin dependencies)
# to be set to user specified log level.
logging.getLogger("werkzeug").setLevel(logging.WARNING)
logging.getLogger().setLevel(logging.{{ loglevel }})

theme = webviz_config.WebvizConfigTheme("{{ theme_name }}")
theme.from_json((Path(__file__).resolve().parent / "theme_settings.json").read_text())

app = dash.Dash(__name__, external_stylesheets=theme.external_stylesheets)
server = app.server

app.title = "{{ title }}"
app.config.suppress_callback_exceptions = True

app.webviz_settings = {
    "shared_settings": webviz_config.SHARED_SETTINGS_SUBSCRIPTIONS.transformed_settings(
        {{ shared_settings }}, {{ config_folder }}, {{ portable }}
    ),
    "portable": {{ portable }},
    "theme": theme,
}

CACHE.init_app(server)

Talisman(server, content_security_policy=theme.csp, feature_policy=theme.feature_policy)

WEBVIZ_STORAGE.use_storage = {{portable}}
WEBVIZ_STORAGE.storage_folder = path.join(
    path.dirname(path.realpath(__file__)), "webviz_storage"
)

WEBVIZ_ASSETS.portable = {{ portable }}
{{ "WEBVIZ_ASSETS.register_app(app)" if not portable else ""}}

SIDEBAR_STYLE = {
    "position": "fixed",
    "top": 0,
    "left": 0,
    "bottom": 0,
    "width": "16rem",
    "padding": "2rem 1rem",
}
CONTENT_STYLE = {
    "margin-left": "18rem",
    "margin-right": "2rem",
    "padding": "2rem 1rem",
}


page_content = defaultdict(dict)
{% for page in pages %}
{% if "pages" in page %}
{% for subpage in page.pages %}
page_content["{{page.id}}"]["{{subpage.id}}"] = [
                  {% for content in subpage.content -%}
                  {%- if content is string -%}
                    dcc.Markdown(r"""{{ content }}""")
                  {%- else -%}
                    {{ content._call_signature[0] }}.{{ content._call_signature[1] }}
                  {%- endif -%}
                  {{- "" if loop.last else ","}}
                  {% endfor -%}
                ]
{% endfor %}
{% else %}
page_content["{{page.id}}"] = [
                  {% for content in page.content -%}
                  {%- if content is string -%}
                    dcc.Markdown(r"""{{ content }}""")
                  {%- else -%}
                    {{ content._call_signature[0] }}.{{ content._call_signature[1] }}
                  {%- endif -%}
                  {{- "" if loop.last else ","}}
                  {% endfor -%}
                ]
{% endif %}

{% endfor %}

if {{ not portable }} and not webviz_config.is_reload_process():
    # When Dash/Flask is started on localhost with hot module reload activated,
    # we do not want the main process to call expensive component functions in
    # the layout tree, as the layout tree used on initialization will anyway be called
    # from the child/restart/reload process.
    app.layout = html.Div()
else:
    sidebar = html.Div(
        children=[
            dbc.Nav(
                children=[
                        {% for page in pages %}
                        
                        {% if "pages" in page %}
                        html.Li(id="{{page.id}}", children=[
                            dbc.Row([
                                dbc.Col(className="styledButton", children="{{page.title}}"),
                            ])
                        ]),
                        dbc.Collapse(
                            [
                            {% for subpage in page.pages %}
                                dbc.NavLink(className="styledButtonSmall", style={'textDecoration':'none'},  children="{{subpage.title}}", href="/{{page.id}}/{{subpage.id}}"),
                            {% endfor %}
                            ],id="{{page.id}}-collapse",
                        )
                        {% else %}
                        html.Li(id="{{page.id}}",  children=[
                             dbc.Row([
                                dbc.Col(className="styledButton", children=dbc.NavLink(style={'textDecoration':'none'}, children="{{page.title}}", href="/{{page.id}}"))])])
                            
                        {% endif %}
                          {{- "" if loop.last else "," -}}
                            {% endfor %}
                            ], vertical=True
                            )], 
            style=SIDEBAR_STYLE,
        id="sidebar",
        className="lead")

    content = html.Div(id="page-content", style=CONTENT_STYLE)
    app.layout = html.Div(
        className="layoutWrapper", children=[dcc.Location(id="url"), sidebar, content]
    )





# this function applies the "open" class to rotate the chevron
def set_navitem_class(is_open):
    if is_open:
        return "open"
    return ""

subpages = []
{% for page in pages %}
{% if "pages" in page %}
@app.callback(
        Output("{{page.id}}-collapse", "is_open"), 
        [Input("{{page.id}}","n_clicks")],
        [State("{{page.id}}-collapse", "is_open")]
        )
# this function is used to toggle the is_open property of each Collapse
def toggle_collapse(n, is_open):
    if n:
        return not is_open
    return is_open
{% endif %}
{% endfor %}

@app.callback(Output("page-content", "children"), [Input("url", "pathname")])
def render_page_content(pathname):
    {% for page in pages %}
    {% if "pages" in page %}
    {% for subpage in page.pages %}
    if pathname == "/{{page.id}}/{{subpage.id}}":
        return page_content["{{page.id}}"]["{{subpage.id}}"]
    {% endfor %}
    {% else %}
    if pathname == "/{{page.id}}":
        return page_content["{{page.id}}"]
    {% endif %}
    {% endfor %}


    # If the user tries to reach a different page, return a 404 message
    return dbc.Jumbotron(
        [
            html.H1("404: Not found", className="text-danger"),
            html.Hr(),
            html.P(f"The pathname {pathname} was not recognised..."),
        ]
    )


if __name__ == "__main__":
    # This part is ignored when the webviz app is started
    # using Docker container and uwsgi (e.g. when hosted on Azure).
    #
    # It is used only when directly running this script with Python,
    # which will then initialize a localhost server.

    port = webviz_config.utils.get_available_port()

    token = webviz_config.LocalhostToken(app.server, port).one_time_token
    webviz_config.LocalhostOpenBrowser(port, token)

    webviz_config.utils.silence_flask_startup()

    app.run_server(
        host="localhost",
        port=port,
        ssl_context=webviz_config.LocalhostCertificate().ssl_context,
        debug=False,
        use_reloader={{not portable}},
      {% if not portable -%}
        dev_tools_hot_reload=True,
        dev_tools_hot_reload_interval=1.0,
        dev_tools_silence_routes_logging=False,
      {% endif %}
    )
